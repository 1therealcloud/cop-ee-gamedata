local sleep_control = nil
local wide = false
class "sleep_dialog" (CUIScriptWnd)
function sleep_dialog:__init() super()
	self:SetWndRect(Frect():set(0,0,1024,768))

	if (is_widescreen()) then
		wide = true
	end

	local xml = CScriptXmlInit()
	self.xml = xml
	--if is_ui_controller() then
	--	xml:ParseFile("ui_sleep_dialog_c.xml")
	--else
		xml:ParseFile("ui_sleep_dialog.xml")
	--end

	self.back = xml:InitStatic("background", self)
--	self.sleep_static = xml:InitSleepStatic("sleep_static", self.back)

	self.sleep_static = xml:InitStatic("sleep_static", self.back)
	self.sleep_static2 = xml:InitStatic("sleep_static", self.back)
	self.static_cover = xml:InitStatic("static_cover", self.back)
	self.st_marker = xml:InitStatic("st_marker", self.static_cover)

	sleep_st_tbl = {}
		for i = 1, 24 do
		sleep_st_tbl[i] = xml:InitStatic("sleep_st_"..i, self.back)
		end

	self.time_track = xml:InitTrackBar("time_track", self.back)
	self:Register(self.time_track, "time_track")

if is_ui_controller() then
	self.btn_sleep = xml:Init3tButton("btn_sleep_c", self.back)
	self:Register(self.btn_sleep, "btn_sleep")

	self.btn_cancel = xml:Init3tButton("btn_cancel_c", self.back)
	self:Register(self.btn_cancel, "btn_cancel")
else
	self.btn_sleep = xml:Init3tButton("btn_sleep", self.back)
	self:Register(self.btn_sleep, "btn_sleep")

	self.btn_cancel = xml:Init3tButton("btn_cancel", self.back)
	self:Register(self.btn_cancel, "btn_cancel")
end
		
	--if not is_ui_controller() then
		self:AddCallback("btn_sleep", ui_events.BUTTON_CLICKED, self.OnButtonSleep, self)
		self:AddCallback("btn_cancel", ui_events.BUTTON_CLICKED, self.OnButtonCancel, self)
	--end

	self.sleep_mb = CUIMessageBoxEx()
	self:Register(self.sleep_mb, "sleep_mb")
--------------------------------------------------------------------------------
	self:AddCallback("sleep_mb", ui_events.MESSAGE_BOX_OK_CLICKED, self.OnMessageBoxOk, self)
	
	action_repeaters():Register(self, key_bindings.kUI_LEFT, 0,0)
	action_repeaters():Register(self, key_bindings.kUI_RIGHT, 0,0)
	self.uiMode = is_ui_controller()
end

function sleep_dialog:__finalize()
	action_repeaters():UnregisterOwner(self)
end

function sleep_dialog:Initialize()
	local cur_hours = level.get_time_hours()
	for i = 1, 24 do
	local hours = cur_hours + i
	if(hours>=24) then
		hours = hours - 24
	end
	sleep_st_tbl[i]:TextControl():SetText(hours..game.translate_string("st_sleep_hours"))
	end

	local scale = 1.0
	--if get_platform_id() == platform_ids.PLATFORM_WIN64 then
		scale = 2.0
	--end
	
	local delta = math.floor(591*scale/24*cur_hours) --[JUD-972] changed texture size to fit new upscaled textures
	self.sleep_static:SetTextureRect(Frect():set(delta,413*scale,591*scale,531*scale)) --[JUD-972] changed texture size to fit new upscaled textures
	local width = (591*scale-delta)/scale --[JUD-972] changed texture size to fit new upscaled textures
	if(wide) then
		width = width*0.8
	end
	self.sleep_static:SetWndSize(vector2():set(width, 128))
	self.sleep_static2:SetTextureRect(Frect():set(0,413*scale,delta,531*scale)) --[JUD-972] changed texture size to fit new upscaled textures
	local width2 = delta/scale
	if(wide) then
		width2 = width2*0.8
	end
	self.sleep_static2:SetWndSize(vector2():set(width2, 128))
	
	local pos = self.sleep_static2:GetWndPos()
	pos.x = self.sleep_static:GetWndPos().x+self.sleep_static:GetWidth()
	self.sleep_static2:SetWndPos(pos)
end

function sleep_dialog:TestAndShow()
	if(db.actor.bleeding>0 or db.actor.radiation>0) then
		self.sleep_mb:InitMessageBox("message_box_ok")
		if(db.actor.bleeding>0 and db.actor.radiation>0) then
			self.sleep_mb:SetText("sleep_warning_all_pleasures")
		elseif(db.actor.bleeding>0) then
			self.sleep_mb:SetText("sleep_warning_bleeding")
		else
			self.sleep_mb:SetText("sleep_warning_radiation")
		end
		self:Initialize()
		self.sleep_mb:ShowDialog(true)
	else
		self:Initialize()
		self:ShowDialog(true)
	end
end

function sleep_dialog:Update()
	CUIScriptWnd.Update(self)
	local sleep_time = self.time_track:GetIValue()-1
	local x = math.floor(591/24*sleep_time)
	if(x==0) then
		x = 5
	end
	if(wide) then
		x = x*0.8
	end

	self.st_marker:SetWndPos(vector2():set(x, 10))
	
	if uiMode ~= is_ui_controller() then
		uiMode = is_ui_controller()
		if not is_ui_controller() then
			self.btn_sleep = self.xml:Init3tButton("btn_sleep", self.back)
			self:Register(self.btn_sleep, "btn_sleep")

			self.btn_cancel = self.xml:Init3tButton("btn_cancel", self.back)
			self:Register(self.btn_cancel, "btn_cancel")
			
			if not is_cursor_visible() then
				show_cursor()	
			end
		else
			self.btn_sleep = self.xml:Init3tButton("btn_sleep_c", self.back)
			self:Register(self.btn_sleep, "btn_sleep")

			self.btn_cancel = self.xml:Init3tButton("btn_cancel_c", self.back)
			self:Register(self.btn_cancel, "btn_cancel")
		end
	end
end

function sleep_dialog:OnTrackButton()
end

function sleep_dialog:OnButtonSleep()
	self:HideDialog()
	xr_effects.disable_ui(db.actor, nil)
	level.add_cam_effector("camera_effects\\sleep.anm", 10, false, "ui_sleep_dialog.dream_callback")
	level.add_pp_effector("sleep_fade.ppe", 11, false)
	db.actor:give_info_portion("actor_is_sleeping")
	_G.mus_vol = get_console():get_float("snd_volume_music")
	_G.amb_vol = get_console():get_float("snd_volume_eff")
	get_console():execute("snd_volume_music 0")
	get_console():execute("snd_volume_eff 0")
	surge_manager.resurrect_skip_message()
end

function sleep_dialog:OnButtonCancel()
	self:HideDialog()
	db.actor:give_info_portion("tutorial_sleep")
	disable_info("sleep_active")
end

function sleep_dialog:OnMessageBoxOk()
	db.actor:give_info_portion("tutorial_sleep")
	disable_info("sleep_active")
end

function sleep_dialog:OnKeyboard(dik, keyboard_action)
	local res = CUIScriptWnd.OnKeyboard(self,dik,keyboard_action)

	if res==false and is_ui_controller() then

		if keyboard_action == ui_events.WINDOW_KEY_PRESSED then
		
			if is_binded(key_bindings.kUI_BACK, dik) then
				self:OnButtonCancel()
				res = true
				
			elseif is_binded(key_bindings.kUI_LEFT, dik) then
				if not any_binded_key_for_action_pressed_c(key_bindings.kUI_RIGHT) then
					self.time_track:StepLeft()
				end
				action_repeaters():SetActionStarted(self, key_bindings.kUI_LEFT)
				res = true
				
			elseif is_binded(key_bindings.kUI_RIGHT, dik) then
				if not any_binded_key_for_action_pressed_c(key_bindings.kUI_LEFT) then
					self.time_track:StepRight()
				end
				action_repeaters():SetActionStarted(self, key_bindings.kUI_RIGHT)
				res = true
			
			elseif is_binded(key_bindings.kUI_ACCEPT, dik) then
				self:OnButtonSleep()
				res = true
				
			end
		end
	end

	return res
end

function sleep_dialog:OnKeyboardHold(dik)
	if is_ui_controller() then

		if is_binded(key_bindings.kUI_LEFT, dik) then
			if action_repeaters():CanRepeatActionNow(self, key_bindings.kUI_LEFT) 
			and not any_binded_key_for_action_pressed_c(key_bindings.kUI_RIGHT) then
				self.time_track:StepLeft()
			end
			return true
			
		elseif is_binded(key_bindings.kUI_RIGHT, dik) then
			if action_repeaters():CanRepeatActionNow(self, key_bindings.kUI_RIGHT) 
			and not any_binded_key_for_action_pressed_c(key_bindings.kUI_LEFT) then
				self.time_track:StepRight()
			end
			return true
		end
	end
	
	return false
end

--------------------------------------------------------------------------------
function dream_callback()
	level.add_cam_effector("camera_effects\\sleep.anm", 10, false, "ui_sleep_dialog.dream_callback2")
	local hours = sleep_control.time_track:GetIValue()
	level.change_game_time(0,hours,0)
	level_weathers.get_weather_manager():forced_weather_change()
	surge_manager.get_surge_manager().time_forwarded = true
	if(surge_manager.is_started() and level_weathers.get_weather_manager().weather_fx) then
		level.stop_weather_fx()
--		level_weathers.get_weather_manager():select_weather(true)
		level_weathers.get_weather_manager():forced_weather_change()
	end
	db.actor.power = 1
    printf("dream_callback: time forwarded on [%d]", hours)
end

function dream_callback2()
	xr_effects.enable_ui(db.actor, nil)
	get_console():execute("snd_volume_music "..tostring(_G.mus_vol))
	get_console():execute("snd_volume_eff "..tostring(_G.amb_vol))
	_G.amb_vol = 0
	_G.mus_vol = 0
	db.actor:give_info_portion("tutorial_sleep")
	disable_info("actor_is_sleeping")
	disable_info("sleep_active")
end

function sleep()
	if(sleep_control==nil) then
		sleep_control = ui_sleep_dialog.sleep_dialog()
	end
	sleep_control.time_track:SetCurrentValue()
	sleep_control:TestAndShow()
	action_repeaters():ResetAll(sleep_control)
end

function main()
	sleep()
end